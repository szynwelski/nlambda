- dodaÄ‡ moduÅ‚ BinaryRelation z ktorego bedzie korzystaÅ‚ graph
- specjalny show dla prostego zbioru atomÃ³w
- pomyÅ›leÄ‡ nad kratÄ… dla folda na zbiorze nominalnym


- dokumentacja za pomoca haddock,
- pragma MINIMAL 
- stworzyc listy eksportowe dla moduÅ‚Ã³w,
- napisaÄ‡ testy jednostkowe

- Formula: 
-- przenieÅ›Ä‡ ifFormula i dodaÄ‡ simplify i solve,
-- ew. przeniesc upraszczanie formul do oddzielnego moduÅ‚u
-- poprawiÄ‡ nawiasowanie przy kwantyfikatorach
-- ustawiÄ‡ infixl dla operatorÃ³w,
-- upraszczanie: 
--- (a /\ b) \/ (a /\ not b) -> a, 
--- (a \/ b) /\ (a \/ not b) -> a /\ not b

- Nominal:
-- zastanowiÄ‡ siÄ™ jaki ma byÄ‡ "strict",
-- dodac instancje dla NominalType, Conditional: Either, Maybe, Map, Set
-- pomyÅ›leÄ‡ nad odpowiednikami operacji z ' na koncu, ktore czesciej rozwiazuja formuly (ewentualnie za pomoca makra #define),
-- sprawdzic czy potrzebne sa wewnetrzne optymalne funkcje: isSubsetOf, intersection, difference.
-- zaimplementowaÄ‡ pairs i podobne,
-- pomyÅ›leÄ‡ nad problemem rozwiÄ…zywania konfliktu nazw zmiennych iteracyjnych - czy istnieje rozwiÄ…zanie "strict"?
-- pomyÅ›leÄ‡ nad problemem obliczania wsparcia dla zbioru: insert a atomSet - moÅ¼e przy "insert" trzeba sprawdziÄ‡ "contains", czyli rozwiÄ…zaÄ‡ formuÅ‚Ä™
-- rozwiÄ…zywanie konfliktÃ³w zmiennych - poziomy zgodnie z zagnieÅ¼dzeniem, a nie: {{{(aâ‚,câ‚,bâ‚) : for bâ‚ âˆŠ ğ”¸} : for câ‚ âˆŠ ğ”¸} : for aâ‚ âˆŠ ğ”¸}
- zrÃ³wnolegliÄ‡ wyszukiwanie zmiennych z rÃ³wnym i rÃ³Å¼nym id w funkcji checkIdentifiers

-- rozmiar zbioru, fold - krata, obliczanie maxa dla funkcji Atom -> Int
-- automatyczne wyliczanie formuÅ‚
-- upraszczanie formuÅ‚ (moze za pomocÄ… Z3)
-- programy: spojnoÅ›Ä‡ w grafie, minimalizacji automatu

Algorytmy:
- zbiory:
-- istnieje ekwiwariantna bijekcja: (A\{a} A\{b} {a,b})
- grafy:
-- dwudzielnosc,
-- trojkolorowalnosc,
-- dijkstra,
-- osiagalnosc,
- automaty:
-- minimalizacja,
-- rownowaznosc.


rozwaÅ¼yÄ‡ eliminacjÄ™ zmiennych nie wystÄ™pujÄ…cych w iteracji i wartoÅ›ci
!!! wykorzystaÄ‡ variants w wariantach, a nie tylko w zbiorach
!!! pomyslec o stosach formula przy uruchamianiu solverow - moze warianty i zbiory powinny miec specyficzne implementacje ite'
